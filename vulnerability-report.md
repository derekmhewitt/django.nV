# Vulnerability Report
Reviewer 1: Derek Hewitt

Reviewer 2: David Banks

Date: October 21st, 2016

## Reviewing Django nV Site

https://github.com/Break-Django/django.nV

## V1: SQL Code Injection
###Exposure
We found an instance of vulnerability to SQL code injection in the Task Manager app located at: /taskManager/2/upload/.
We exploited this vulnerability by injecting the following code:

somePicture',(SELECT * FROM *);

This vulnerability would be exposed by any valid SQL queries input into the file upload text box.

By exploiting SQL Code Injection on this site we would be able to retrieve information on user accounts (names, email addresses, hashed passwords) and copies of any data stored in the database.

###Repair
The vulnerability is caused by the following code in views.py:
```
curs = connection.cursor()
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
```

This exploit could be repaired by replacing the above code with code similar to the following:

views.py
```
    file = File(name=name, path=upload_path, project_id=project_id)
    file.save()
```

## V2: Broken Authentication and Session Management
### Exposure
We found an instance of broken authentication by forging a valid user request with the is_superuser flag set to True on the account creation page.  Because the site used an incomplete whitelist instead of a blacklist of user account form fields they forgot to exclude is_superuser.

By exploiting the site's broken authentication we're able to create a superuser account which then has admin level access to all the information on the site itself.  It's pretty obviously bad if someone can do that from your account sign up page.

### Repair
The vulnerability is caused by the following code in forms.py:
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```

It would be easy for anyone to forget to exclude an important field in a blacklist, therefore it's better practice to use a whitelist and explicitly add only safe form fields to that whitelist.

Some example code that would solve our problem (and replace the above code) would look like in forms.py:
```
class UserForm(forms.ModelForm):
    """User registration form here"""
    class Meta:
        model = User
        include = ['username', 'password', 'email']
```
We want the absolute minimum options on our user account creation and just allow the user to add or change this information at a later date, after they've set up an account and authenticated.

## V3: Cross-Site Scripting (XSS)
### Exposure
We found a location in this site's code where XSS attacks could take place.  It's located in the display of the task.text attribute in the task_details.html file.

By exploiting XSS we would be able to execute html or javascript of our choice on the browers of anyone who viewed our task, which is obviously bad.

### Repair
We found the problem in task_details.html:
```
<div class="col-md-10">
    <p><span class="bold">Description:</span>
        <span class="p-team">
          {{task.text|safe}}
        </span>
    </p>
</div>
```

Simply not using the |safe filter here would solve our problem:
```
<div class="col-md-10">
    <p><span class="bold">Description:</span>
        <span class="p-team">
          {{ task.text }}
        </span>
    </p>
</div>
```

## V4: Insecure Direct Oject Reference
### Exposure
We found several instances of insecure direct object references in our site's views file.

By exploiting these vulnerabilities we were able to add, delete and modify object that did not belong to our user account, and some of them were egregious enough that we didn't even have to be logged in.

### Repair
This issue is located in a few places in our code base, here is an example from views.py:
```
def task_create(request, project_id):

    if request.method == 'POST':

        proj = Project.objects.get(pk=project_id)

        text = request.POST.get('text', False)
        task_title = request.POST.get('task_title', False)
        now = timezone.now()
        task_duedate = timezone.now() + datetime.timedelta(weeks=1)
        if request.POST.get('task_duedate') != '':
            task_duedate = datetime.datetime.fromtimestamp(
                int(request.POST.get('task_duedate', False)))

        task = Task(
            text=text,
            title=task_title,
            start_date=now,
            due_date=task_duedate,
            project=proj)

        task.save()
        task.users_assigned = [request.user]

        return redirect('/taskManager/' + project_id +
                        '/', {'new_task_added': True})
    else:
        return render_to_response(
            'taskManager/task_create.html', {'proj_id': project_id}, RequestContext(request))
```

This could be solved by adding a few lines into our code:
```
from django.core.exceptions import PermissionDenied

def task_create(request, project_id):
    user = request.user
    if not user.is_authenticated:
        raise PermissionDenied(template_name="403.html")
    # code continues on from there without further modification
    if request.method == 'POST':
```

I like waffles.